# ADR-004: Malware Radar - Anomaly Detection from Memory Signatures

## Status
Proposed

## Date
2025-01-25

## Context

Traditional antivirus solutions rely on:
- Signature matching (known malware only)
- Heuristic rules (high false positives)
- Behavioral sandboxing (resource intensive)

RuVector has unique visibility into memory patterns that malware cannot hide:
- Memory allocation patterns
- Process memory footprints over time
- Unusual memory access patterns
- Hidden process detection via memory accounting gaps

Malware exhibits distinctive memory behaviors:
- Crypto miners: Steady high memory + CPU correlation
- Keyloggers: Small footprint, persistent, hooks input
- Rootkits: Memory accounting discrepancies
- Ransomware: Rapid file I/O + memory pattern changes

## Decision

Implement **Memory-Based Anomaly Detection** as a lightweight malware radar.

### Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                      Malware Radar System                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────────────┐   │
│  │  Baseline   │   │  Anomaly    │   │    Threat           │   │
│  │  Profiler   │──▶│  Detector   │──▶│    Classifier       │   │
│  │             │   │             │   │                     │   │
│  │ • Normal    │   │ • Z-score   │   │ • Miner             │   │
│  │   patterns  │   │ • Isolation │   │ • Keylogger         │   │
│  │ • Process   │   │   Forest    │   │ • Rootkit           │   │
│  │   baselines │   │ • HNSW      │   │ • Ransomware        │   │
│  └─────────────┘   └─────────────┘   │ • RAT               │   │
│                                       │ • Unknown           │   │
│                                       └─────────────────────┘   │
│                            │                                     │
│                            ▼                                     │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                    Alert System                            │  │
│  │  • Tray notification                                       │  │
│  │  • Process isolation recommendation                        │  │
│  │  • Detailed forensic report                                │  │
│  │  • Optional: Auto-quarantine                               │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Detection Signatures

| Malware Type | Memory Signature |
|--------------|------------------|
| **Crypto Miner** | Steady 90%+ CPU, stable high memory, GPU correlation |
| **Keylogger** | Tiny footprint (<10MB), persistent, hooks system processes |
| **Rootkit** | Memory accounting gaps, hidden processes |
| **Ransomware** | Rapid memory churn, file handle explosion |
| **RAT** | Periodic network bursts, screenshot-like memory patterns |
| **Botnet** | Synchronized activity patterns across restarts |

### Feature Vector

```rust
pub struct ProcessMemorySignature {
    // Static features
    pub base_memory_mb: f32,
    pub peak_memory_mb: f32,
    pub memory_volatility: f32,      // std dev of memory over time

    // Behavioral features
    pub allocation_rate: f32,         // MB/sec average
    pub deallocation_rate: f32,
    pub memory_churn: f32,            // alloc + dealloc rate

    // Temporal features
    pub active_hours: Vec<u8>,        // 24-hour activity bitmap
    pub uptime_pattern: UptimePattern,

    // Correlation features
    pub cpu_memory_correlation: f32,
    pub network_memory_correlation: f32,
    pub disk_memory_correlation: f32,

    // Anomaly scores
    pub isolation_score: f32,         // Isolation Forest score
    pub hnsw_distance: f32,           // Distance from known-good
}
```

### API Design

```rust
pub struct MalwareRadar {
    baseline: ProcessBaselines,
    detector: AnomalyDetector,
    classifier: ThreatClassifier,
}

impl MalwareRadar {
    /// Initialize and start background monitoring
    pub fn start(&mut self) -> Result<(), Error>;

    /// Get current threat assessment
    pub fn scan(&self) -> ThreatReport;

    /// Check specific process
    pub fn analyze_process(&self, pid: u32) -> ProcessThreatLevel;

    /// Get all suspicious processes
    pub fn get_suspicious(&self) -> Vec<SuspiciousProcess>;

    /// Report false positive (improves model)
    pub fn mark_safe(&mut self, pid: u32);
}

pub enum ThreatLevel {
    Clean,
    Suspicious { confidence: f32, reason: String },
    Likely { threat_type: ThreatType, confidence: f32 },
    Critical { threat_type: ThreatType, action: RecommendedAction },
}
```

### Detection Approach

1. **Baseline Learning** (first 24-48 hours)
   - Profile normal process behaviors
   - Build per-process memory baselines
   - Establish system-wide patterns

2. **Continuous Monitoring**
   - Sample process memory every 5 seconds
   - Update rolling statistics
   - Check against baselines

3. **Anomaly Detection**
   - Isolation Forest for outlier detection
   - HNSW distance from known-good patterns
   - Rule-based signature matching

4. **Classification**
   - Multi-class classifier for threat type
   - Confidence scoring
   - Explainable results

### Privacy & Safety

- No file scanning (not an AV replacement)
- No network transmission
- No process termination without user consent
- Designed to complement, not replace, existing AV

## Consequences

### Positive
- Detects zero-day malware by behavior
- Extremely lightweight (< 1% CPU)
- No signature updates needed
- Catches malware that evades traditional AV

### Negative
- Learning period required
- False positives for unusual legitimate software
- Not a complete security solution
- Requires user judgment for alerts

### Risks
- Sophisticated malware may mimic normal behavior
- Alert fatigue if too sensitive
- Users may over-rely on it

## Implementation Phases

### Phase 1: Baseline Infrastructure (1 week)
- Process memory tracking
- Baseline storage format
- Basic statistics collection

### Phase 2: Anomaly Detection (2 weeks)
- Isolation Forest implementation
- Z-score detection
- HNSW distance calculation

### Phase 3: Classification (2 weeks)
- Threat type classifier
- Signature matching rules
- Confidence calibration

### Phase 4: UI & Alerts (1 week)
- Tray notifications
- Detailed report view
- User feedback mechanism

## Success Metrics

| Metric | Target |
|--------|--------|
| Detection Rate (known malware) | > 80% |
| False Positive Rate | < 5% |
| Detection Time | < 60 seconds |
| CPU Overhead | < 1% |
| Memory Overhead | < 50 MB |

## References

- [Memory-Based Malware Detection](https://www.usenix.org/conference/usenixsecurity20/presentation/liu-yizheng)
- [Isolation Forest Algorithm](https://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/icdm08b.pdf)
- Existing: `src/neural/hnsw_patterns.rs`, `src/algorithms/spectral.rs`
